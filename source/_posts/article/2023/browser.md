---
title: 浏览器原理
tags:
  - 浏览器
categories: 前端
cover: https://may-data.oss-cn-hangzhou.aliyuncs.com/myartilepic/a30f7a789262dcddce8a5de3a9036309.png
date: 2023-02-16 16:00:00
---

![](https://may-data.oss-cn-hangzhou.aliyuncs.com/image/202302161556742.png)

一、浏览器安全 1. 什么是 XSS 攻击？
（1）概念
XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。
XSS 的本质是因为网站没有对恶意代码进行过滤
攻击者可以通过这种攻击方式可以进行以下操作：
获取页面的数据，如 DOM、cookie、localStorage；
DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
破坏页面结构；
流量劫持（将链接指向某网站）；

        （2）攻击类型
            XSS 可以分为存储型、反射型和 DOM 型
                存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
                反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。
                DOM 型指的通过修改页面的 DOM 节点形成的 XSS。



    2. 如何防御 XSS 攻击？
        对html中代码做好充分转义
        使用CSP内容安全策略
        对敏感信息保护，cookie使用http-only，使用验证码

    3. 什么是 CSRF 攻击？
        （1）概念
            CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
            CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

        （2）攻击类型
            GET 类型
            POST 类型
            链接类型


    4. 如何防御 CSRF 攻击？
        同源检测，http请求头的origin和refer
        csrf token验证
        cookie双重验证
        设置samesite

二、进程与线程 1. 进程与线程的概念
进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
线程是进程中的更小单位，描述了执行一段指令所需的时间。
进程是资源分配的最小单位，线程是 CPU 调度的最小单位。

    浏览器进程
        浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
        渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
        GPU 进程：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
        网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
        插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
        打开一个网页，最少需要四个进程：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

    2. 进程和线程的区别
        进程可以看做独立应用，线程不能
        资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
        通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
        进程切换比线程切换的开销要大
        系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。

    3. 浏览器渲染进程的线程有哪些
        GUI渲染线程
        JS引擎线程
        事件触发线程
        定时器触发进程
        异步http请求线程

    4. 进程之间的通信方式
        管道通信
            最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。

        消息队列通信
            消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。

        信号量通信
        信号通信
        共享内存通信
        套接字通信

    7. 如何实现浏览器内多个标签页之间的通信?
        使用 websocket 协议
        使用 SharedWorker
        使用 localStorage 
        使用 postMessage 方法

    8. 对Service Worker的理解
        Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。
        Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

三、浏览器缓存 1. 对浏览器的缓存机制的理解
第一次加载资源，缓存
下一次强制缓存，canche-control 的 max-age，1.0 使用 expires
已过期，开始协商缓存，发送 if-none-match 和 if-modified-since
根据 Etag 值判断是否修改，一致返回 304，不一致返回新的资源
没有 Etag 则和 last-modified 对比一致返回 304，不一致返回新的资源

    2. 浏览器资源缓存的位置有哪些？
        资源缓存的位置一共有 3 种，按优先级从高到低分别是：
        Service Worker：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。
        Memory Cache：Memory Cache 就是内存缓存，它的效率最快，**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。
        Disk Cache：Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上。
        Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。

    5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？
        点击刷新按钮或者按 F5：直接发起协商缓存请求
        用户按 Ctrl+F5（强制刷新）：直接请求资源，不走缓存策略
        地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容

四、浏览器组成 1. 对浏览器的理解
浏览器可以分为两部分，shell 和 内核。
shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。
内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。

    2. 对浏览器内核的理解
        浏览器内核主要分成两部分：
        渲染引擎
        js引擎

    4. 常见浏览器所用内核
        IE：Trident
        Chrome/Edge：Blink
        Firefox：Gecko
        Safari：Webkit
        Opera：Blink

五、浏览器渲染原理 1. 浏览器的渲染过程
DOM 树
CSS 树
渲染树
布局：当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小
绘制：遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

    2. 浏览器渲染优化
        针对js：js脚本放body最后，使用异步加载js脚本
        针对css：导入外部样式使用link，不用import，css少使用内嵌样式
        针对dom树css树：html层级不要太深，使用语义化标签，减少css代码层级
        针对回流重绘：减少dom操作；不用table；使用绝对定位；元素先displaynone操作完再显示；多个dom操作放一起执行

    6. 如何优化关键渲染路径？
        为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：
            （1）关键资源的数量。
            （2）关键路径长度。
            （3）关键字节的数量。

        优化关键渲染路径的常规步骤如下：
            （1）对关键路径进行分析和特性描述：资源数、字节数、长度。
            （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。
            （3）优化关键字节数以缩短下载时间（往返次数）。
            （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度

六、浏览器本地存储 4. 前端储存的⽅式有哪些？
cookie
localStorage
sessionStorage
WebSql
IndexedDB

七、浏览器同源策略 1. 什么是同源策略
同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。

    2. 如何解决跨域问题
        CORS
            跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。
            CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了
            浏览器将CORS分为简单请求和非简单请求：
                简单请求
                    请求方法是head、get、post
                    头信息不超出Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
                    过程：
                        对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。


                非简单请求
                    请求方法为delete、put等
                    非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求。
                    预检请求使用的请求方法是OPTIONS，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。
                    在非简单请求中，至少需要设置以下字段：'Access-Control-Allow-Origin'、'Access-Control-Allow-Methods'、'Access-Control-Allow-Headers'


            CORS中Cookie相关问题
                在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：
                    在请求中设置 **withCredentials**
                    Access-Control-Allow-Credentials 设置为 true
                    Access-Control-Allow-Origin 设置为非 *



        JSONP
            jsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

        postMessage 跨域
        nginx代理跨域
        nodejs 中间件代理跨域
        document.domain + iframe跨域
        location.hash + iframe跨域
        window.name + iframe跨域
        WebSocket协议跨域

    4. Nginx的概念及其工作原理
        Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。
        Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。

八、浏览器事件机制 1. 事件是什么？事件模型？
事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。
DOM0 级事件模型，这种模型不会传播，所以没有事件流的概念
IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。
DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。

    2. 如何阻止事件冒泡
        普通浏览器使用：event.stopPropagation()
        IE浏览器使用：event.cancelBubble = true;

    3. 对事件委托的理解
        事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件

    6. 对事件循环的理解
        首先执行同步代码，这属于宏任务
        当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
        执行所有微任务
        当执行完所有微任务后，如有必要会渲染页面
        然后开始下一轮 Event Loop，执行宏任务中的异步代码

九、浏览器垃圾回收机制 1. V8 的垃圾回收机制是怎样的
V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。
（1）新生代算法
新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。
在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

        （2）老生代算法
            老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。
            对象会出现在老生代空间中：
                新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
                To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

            在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。
            清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。


    2. 哪些操作会造成内存泄漏？
        意外的全局变量
        定时器
        dom引用
        不合理的闭包
